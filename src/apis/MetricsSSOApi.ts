/* tslint:disable */
/* eslint-disable */
/**
 * metrics-sdk-sso
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 5.0.8
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AcceptedTermsVersionResponse,
  CheckReturnRouteResponse,
  EmailAddressResponse,
  ExchangeableUserResponse,
  FacilityResponse,
  HeightMeasurementResponse,
  OAuthServiceListResponse,
  OAuthServiceResponse,
  OauthResponse,
  OauthServiceSubscriptionListResponse,
  OauthServiceSubscriptionResponse,
  ProfileResponse,
  RedirectResponse,
  UserResponse,
  WeightMeasurementResponse,
} from '../models';
import {
    AcceptedTermsVersionResponseFromJSON,
    AcceptedTermsVersionResponseToJSON,
    CheckReturnRouteResponseFromJSON,
    CheckReturnRouteResponseToJSON,
    EmailAddressResponseFromJSON,
    EmailAddressResponseToJSON,
    ExchangeableUserResponseFromJSON,
    ExchangeableUserResponseToJSON,
    FacilityResponseFromJSON,
    FacilityResponseToJSON,
    HeightMeasurementResponseFromJSON,
    HeightMeasurementResponseToJSON,
    OAuthServiceListResponseFromJSON,
    OAuthServiceListResponseToJSON,
    OAuthServiceResponseFromJSON,
    OAuthServiceResponseToJSON,
    OauthResponseFromJSON,
    OauthResponseToJSON,
    OauthServiceSubscriptionListResponseFromJSON,
    OauthServiceSubscriptionListResponseToJSON,
    OauthServiceSubscriptionResponseFromJSON,
    OauthServiceSubscriptionResponseToJSON,
    ProfileResponseFromJSON,
    ProfileResponseToJSON,
    RedirectResponseFromJSON,
    RedirectResponseToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
    WeightMeasurementResponseFromJSON,
    WeightMeasurementResponseToJSON,
} from '../models';

export interface AcceptedTermsVersionShowRequest {
    userId?: number;
    apiVersion?: string;
}

export interface AcceptedTermsVersionUpdateRequest {
    revision?: string;
    userId?: number;
    apiVersion?: string;
}

export interface AuthConnectRequest {
    email: string;
    password: string;
    apiVersion?: string;
}

export interface AuthElevateRequest {
    otpToken?: string;
    refreshable?: boolean;
    apiVersion?: string;
}

export interface AuthExchangeFulfillmentRequest {
    exchangeToken: string;
    apiVersion?: string;
}

export interface AuthExchangeInitRequest {
    authorization: string;
    apiVersion?: string;
}

export interface AuthFacilityWelcomeFulfillmentRequest {
    password: string;
    welcomeToken: string;
    refreshable?: boolean;
    apiVersion?: string;
}

export interface AuthKeepAliveRequest {
    apiVersion?: string;
}

export interface AuthLoginRequest {
    email: string;
    password: string;
    refreshable?: boolean;
    apiVersion?: string;
}

export interface AuthLogoutRequest {
    global?: boolean;
    apiVersion?: string;
}

export interface AuthResetFulfillmentRequest {
    password: string;
    resetToken: string;
    refreshable?: boolean;
    apiVersion?: string;
}

export interface AuthResetRequestRequest {
    email: string;
    returnUrl: string;
    requiresElevated?: boolean;
    apiVersion?: string;
}

export interface AuthSetFacilityRequest {
    facilityId: number;
    refreshable?: boolean;
    userId?: number;
    apiVersion?: string;
}

export interface AuthUpdateRequest {
    password: string;
    userId?: number;
    apiVersion?: string;
}

export interface AuthUserInitRequest {
    email: string;
    returnUrl: string;
    birthday?: Date;
    gender?: string;
    language?: string;
    metricHeight?: number;
    metricWeight?: number;
    name?: string;
    refreshable?: boolean;
    requiresElevated?: boolean;
    units?: string;
    apiVersion?: string;
}

export interface AuthUserInitFulfillmentRequest {
    acceptedTermsRevision: string;
    authorizationCode: string;
    birthday: Date;
    gender: string;
    name: string;
    password: string;
    units: string;
    language?: string;
    metricHeight?: number;
    metricWeight?: number;
    refreshable?: boolean;
    apiVersion?: string;
}

export interface AuthValidateReturnRouteRequest {
    returnUrl: string;
    apiVersion?: string;
}

export interface BasicCredentialCreateRequest {
    email: string;
    password: string;
    apiVersion?: string;
}

export interface BasicCredentialUpdateRequest {
    password: string;
    userId?: number;
    apiVersion?: string;
}

export interface EmailAddressValidationFulfillmentRequest {
    validationToken: string;
    apiVersion?: string;
}

export interface HeightMeasurementCreateRequest {
    metricHeight: number;
    source: string;
    takenAt: Date;
    userId?: number;
    apiVersion?: string;
}

export interface OauthAuthorizeRequest {
    clientIdentifier: string;
    redirectUrl: string;
    responseType: string;
    state: string;
    apiVersion?: string;
}

export interface OauthDeauthorizeRequest {
    accessToken: string;
    apiVersion?: string;
}

export interface OauthInitiateRequest {
    redirect: string;
    service: string;
    type: string;
    apiVersion?: string;
}

export interface OauthServiceDeleteRequest {
    id: number;
    userId?: number;
    apiVersion?: string;
}

export interface OauthServiceListRequest {
    ascending?: boolean;
    limit?: number;
    offset?: number;
    service?: string;
    sort?: string;
    userId?: number;
    apiVersion?: string;
}

export interface OauthServiceShowRequest {
    id: number;
    userId?: number;
    apiVersion?: string;
}

export interface OauthServiceSubscriptionCreateRequest {
    model: string;
    creation?: boolean;
    deletion?: boolean;
    oauthServiceId?: number;
    updates?: boolean;
    userId?: number;
    apiVersion?: string;
}

export interface OauthServiceSubscriptionDeleteRequest {
    id: number;
    userId?: number;
    apiVersion?: string;
}

export interface OauthServiceSubscriptionListRequest {
    ascending?: boolean;
    authorization?: string;
    limit?: number;
    model?: string;
    offset?: number;
    service?: string;
    sort?: string;
    userId?: number;
    apiVersion?: string;
}

export interface OauthServiceSubscriptionShowRequest {
    id: number;
    userId?: number;
    apiVersion?: string;
}

export interface OauthTokenRequest {
    clientIdentifier: string;
    clientSecret: string;
    grantType: string;
    authorizationCode?: string;
    refreshToken?: string;
    apiVersion?: string;
}

export interface ProfileUpdateRequest {
    birthday?: Date;
    gender?: string;
    language?: string;
    name?: string;
    units?: string;
    userId?: number;
    apiVersion?: string;
}

export interface WeightMeasurementCreateRequest {
    metricWeight: number;
    source: string;
    takenAt: Date;
    bodyFatPercentage?: number;
    userId?: number;
    apiVersion?: string;
}

/**
 * 
 */
export class MetricsSSOApi extends runtime.BaseAPI {

    /**
     * 1
     * Show a user accepted terms version
     */
    async acceptedTermsVersionShow(requestParameters: AcceptedTermsVersionShowRequest): Promise<AcceptedTermsVersionResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/accepted-terms-version`,
            action: 'acceptedTermsVersion:show',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Update a user accepted terms version
     */
    async acceptedTermsVersionUpdate(requestParameters: AcceptedTermsVersionUpdateRequest): Promise<AcceptedTermsVersionResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.revision) {
            queryParameters['revision'] = requestParameters.revision;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/accepted-terms-version`,
            action: 'acceptedTermsVersion:update',
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Connect a user to auth using email and password
     */
    async authConnect(requestParameters: AuthConnectRequest): Promise<UserResponse> {
        if (requestParameters.email === null || requestParameters.email === undefined) {            
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authConnect.');
        }
        
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authConnect.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.email) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/connect`,
            action: 'auth:connect',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Elevate user session to Global ACL
     */
    async authElevate(requestParameters: AuthElevateRequest): Promise<ExchangeableUserResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.otpToken) {
            queryParameters['otpToken'] = requestParameters.otpToken;
        }

        
        if (requestParameters.refreshable) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/elevate`,
            action: 'auth:elevate',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Exchanges an authorization token for access and refresh tokens
     */
    async authExchangeFulfillment(requestParameters: AuthExchangeFulfillmentRequest): Promise<UserResponse> {
        if (requestParameters.exchangeToken === null || requestParameters.exchangeToken === undefined) {            
            throw new runtime.RequiredError('exchangeToken','Required parameter requestParameters.exchangeToken was null or undefined when calling authExchangeFulfillment.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.exchangeToken) {
            queryParameters['exchangeToken'] = requestParameters.exchangeToken;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/exchange/fulfillment`,
            action: 'auth:exchangeFulfillment',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Generate an exchange token
     */
    async authExchangeInit(requestParameters: AuthExchangeInitRequest): Promise<ExchangeableUserResponse> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {            
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling authExchangeInit.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.authorization) {
            queryParameters['authorization'] = requestParameters.authorization;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/exchange/init`,
            action: 'auth:exchangeInit',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Fulfills a facility\'s user creation process
     */
    async authFacilityWelcomeFulfillment(requestParameters: AuthFacilityWelcomeFulfillmentRequest): Promise<ExchangeableUserResponse> {
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authFacilityWelcomeFulfillment.');
        }
        
        if (requestParameters.welcomeToken === null || requestParameters.welcomeToken === undefined) {            
            throw new runtime.RequiredError('welcomeToken','Required parameter requestParameters.welcomeToken was null or undefined when calling authFacilityWelcomeFulfillment.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.refreshable) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.welcomeToken) {
            queryParameters['welcomeToken'] = requestParameters.welcomeToken;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/facility/welcome/fulfillment`,
            action: 'auth:facilityWelcomeFulfillment',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Keeps a user\'s tokens alive
     */
    async authKeepAlive(requestParameters: AuthKeepAliveRequest): Promise<void> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/keep-alive`,
            action: 'auth:keepAlive',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 2
     * Login a user using email and password
     */
    async authLogin(requestParameters: AuthLoginRequest): Promise<ExchangeableUserResponse> {
        if (requestParameters.email === null || requestParameters.email === undefined) {            
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authLogin.');
        }
        
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authLogin.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.email) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.refreshable) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 2;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/login`,
            action: 'auth:login',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Logout user by blacklisting token
     */
    async authLogout(requestParameters: AuthLogoutRequest): Promise<void> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.global) {
            queryParameters['global'] = requestParameters.global;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/logout`,
            action: 'auth:logout',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 2
     * Fulfills a user\'s credential reset request
     */
    async authResetFulfillment(requestParameters: AuthResetFulfillmentRequest): Promise<ExchangeableUserResponse> {
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authResetFulfillment.');
        }
        
        if (requestParameters.resetToken === null || requestParameters.resetToken === undefined) {            
            throw new runtime.RequiredError('resetToken','Required parameter requestParameters.resetToken was null or undefined when calling authResetFulfillment.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.refreshable) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.resetToken) {
            queryParameters['resetToken'] = requestParameters.resetToken;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 2;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/reset/fulfillment`,
            action: 'auth:resetFulfillment',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 2
     * Request to reset a user\'s credentials
     */
    async authResetRequest(requestParameters: AuthResetRequestRequest): Promise<void> {
        if (requestParameters.email === null || requestParameters.email === undefined) {            
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authResetRequest.');
        }
        
        if (requestParameters.returnUrl === null || requestParameters.returnUrl === undefined) {            
            throw new runtime.RequiredError('returnUrl','Required parameter requestParameters.returnUrl was null or undefined when calling authResetRequest.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.email) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.requiresElevated) {
            queryParameters['requiresElevated'] = requestParameters.requiresElevated;
        }

        
        if (requestParameters.returnUrl) {
            queryParameters['returnUrl'] = requestParameters.returnUrl;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 2;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/reset/request`,
            action: 'auth:resetRequest',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

    }

    /**
     * 1
     * Sets the target facility for a user
     */
    async authSetFacility(requestParameters: AuthSetFacilityRequest): Promise<FacilityResponse> {
        if (requestParameters.facilityId === null || requestParameters.facilityId === undefined) {            
            throw new runtime.RequiredError('facilityId','Required parameter requestParameters.facilityId was null or undefined when calling authSetFacility.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.refreshable) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.facilityId !== undefined || requestParameters.facilityId !== null) {
            pathParameters['facilityId'] = requestParameters.facilityId;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/set-facility/{facilityId}`.replace(`{${"facilityId"}}`, encodeURIComponent(String(requestParameters.facilityId))),
            action: 'auth:setFacility',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Update a user\'s credentials
     */
    async authUpdate(requestParameters: AuthUpdateRequest): Promise<UserResponse> {
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authUpdate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/update`,
            action: 'auth:update',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Initialize a new user
     */
    async authUserInit(requestParameters: AuthUserInitRequest): Promise<void> {
        if (requestParameters.email === null || requestParameters.email === undefined) {            
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authUserInit.');
        }
        
        if (requestParameters.returnUrl === null || requestParameters.returnUrl === undefined) {            
            throw new runtime.RequiredError('returnUrl','Required parameter requestParameters.returnUrl was null or undefined when calling authUserInit.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.birthday) {
            queryParameters['birthday'] = (requestParameters.birthday as any).toISOString();
        }

        
        if (requestParameters.email) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.gender) {
            queryParameters['gender'] = requestParameters.gender;
        }

        
        if (requestParameters.language) {
            queryParameters['language'] = requestParameters.language;
        }

        
        if (requestParameters.metricHeight) {
            queryParameters['metricHeight'] = requestParameters.metricHeight;
        }

        
        if (requestParameters.metricWeight) {
            queryParameters['metricWeight'] = requestParameters.metricWeight;
        }

        
        if (requestParameters.name) {
            queryParameters['name'] = requestParameters.name;
        }

        
        if (requestParameters.refreshable) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.requiresElevated) {
            queryParameters['requiresElevated'] = requestParameters.requiresElevated;
        }

        
        if (requestParameters.returnUrl) {
            queryParameters['returnUrl'] = requestParameters.returnUrl;
        }

        
        if (requestParameters.units) {
            queryParameters['units'] = requestParameters.units;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/user/init`,
            action: 'auth:userInit',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

    }

    /**
     * 1
     * Fulfill a new user initialization
     */
    async authUserInitFulfillment(requestParameters: AuthUserInitFulfillmentRequest): Promise<ExchangeableUserResponse> {
        if (requestParameters.acceptedTermsRevision === null || requestParameters.acceptedTermsRevision === undefined) {            
            throw new runtime.RequiredError('acceptedTermsRevision','Required parameter requestParameters.acceptedTermsRevision was null or undefined when calling authUserInitFulfillment.');
        }
        
        if (requestParameters.authorizationCode === null || requestParameters.authorizationCode === undefined) {            
            throw new runtime.RequiredError('authorizationCode','Required parameter requestParameters.authorizationCode was null or undefined when calling authUserInitFulfillment.');
        }
        
        if (requestParameters.birthday === null || requestParameters.birthday === undefined) {            
            throw new runtime.RequiredError('birthday','Required parameter requestParameters.birthday was null or undefined when calling authUserInitFulfillment.');
        }
        
        if (requestParameters.gender === null || requestParameters.gender === undefined) {            
            throw new runtime.RequiredError('gender','Required parameter requestParameters.gender was null or undefined when calling authUserInitFulfillment.');
        }
        
        if (requestParameters.name === null || requestParameters.name === undefined) {            
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling authUserInitFulfillment.');
        }
        
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authUserInitFulfillment.');
        }
        
        if (requestParameters.units === null || requestParameters.units === undefined) {            
            throw new runtime.RequiredError('units','Required parameter requestParameters.units was null or undefined when calling authUserInitFulfillment.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.acceptedTermsRevision) {
            queryParameters['acceptedTermsRevision'] = requestParameters.acceptedTermsRevision;
        }

        
        if (requestParameters.authorizationCode) {
            queryParameters['authorizationCode'] = requestParameters.authorizationCode;
        }

        
        if (requestParameters.birthday) {
            queryParameters['birthday'] = (requestParameters.birthday as any).toISOString();
        }

        
        if (requestParameters.gender) {
            queryParameters['gender'] = requestParameters.gender;
        }

        
        if (requestParameters.language) {
            queryParameters['language'] = requestParameters.language;
        }

        
        if (requestParameters.metricHeight) {
            queryParameters['metricHeight'] = requestParameters.metricHeight;
        }

        
        if (requestParameters.metricWeight) {
            queryParameters['metricWeight'] = requestParameters.metricWeight;
        }

        
        if (requestParameters.name) {
            queryParameters['name'] = requestParameters.name;
        }

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.refreshable) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.units) {
            queryParameters['units'] = requestParameters.units;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/user/init/fulfillment`,
            action: 'auth:userInitFulfillment',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Validates redirect url for known good routes
     */
    async authValidateReturnRoute(requestParameters: AuthValidateReturnRouteRequest): Promise<CheckReturnRouteResponse> {
        if (requestParameters.returnUrl === null || requestParameters.returnUrl === undefined) {            
            throw new runtime.RequiredError('returnUrl','Required parameter requestParameters.returnUrl was null or undefined when calling authValidateReturnRoute.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.returnUrl) {
            queryParameters['returnUrl'] = requestParameters.returnUrl;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/validate/return-route`,
            action: 'auth:validateReturnRoute',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Create auth using email and password for user
     */
    async basicCredentialCreate(requestParameters: BasicCredentialCreateRequest): Promise<UserResponse> {
        if (requestParameters.email === null || requestParameters.email === undefined) {            
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling basicCredentialCreate.');
        }
        
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling basicCredentialCreate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.email) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/basic-credential`,
            action: 'basicCredential:create',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Update a user\'s credentials
     */
    async basicCredentialUpdate(requestParameters: BasicCredentialUpdateRequest): Promise<UserResponse> {
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling basicCredentialUpdate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.password) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/basic-credential/update`,
            action: 'basicCredential:update',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Fulfills a user\'s email validation process
     */
    async emailAddressValidationFulfillment(requestParameters: EmailAddressValidationFulfillmentRequest): Promise<EmailAddressResponse> {
        if (requestParameters.validationToken === null || requestParameters.validationToken === undefined) {            
            throw new runtime.RequiredError('validationToken','Required parameter requestParameters.validationToken was null or undefined when calling emailAddressValidationFulfillment.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.validationToken !== undefined || requestParameters.validationToken !== null) {
            pathParameters['validationToken'] = requestParameters.validationToken;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user/email-address/validation-fulfillment/{validationToken}`.replace(`{${"validationToken"}}`, encodeURIComponent(String(requestParameters.validationToken))),
            action: 'emailAddress:validationFulfillment',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Create a user height measurement
     */
    async heightMeasurementCreate(requestParameters: HeightMeasurementCreateRequest): Promise<HeightMeasurementResponse> {
        if (requestParameters.metricHeight === null || requestParameters.metricHeight === undefined) {            
            throw new runtime.RequiredError('metricHeight','Required parameter requestParameters.metricHeight was null or undefined when calling heightMeasurementCreate.');
        }
        
        if (requestParameters.source === null || requestParameters.source === undefined) {            
            throw new runtime.RequiredError('source','Required parameter requestParameters.source was null or undefined when calling heightMeasurementCreate.');
        }
        
        if (requestParameters.takenAt === null || requestParameters.takenAt === undefined) {            
            throw new runtime.RequiredError('takenAt','Required parameter requestParameters.takenAt was null or undefined when calling heightMeasurementCreate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.metricHeight) {
            queryParameters['metricHeight'] = requestParameters.metricHeight;
        }

        
        if (requestParameters.source) {
            queryParameters['source'] = requestParameters.source;
        }

        
        if (requestParameters.takenAt) {
            queryParameters['takenAt'] = (requestParameters.takenAt as any).toISOString();
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user/height-measurement`,
            action: 'heightMeasurement:create',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Authorizes a third party application
     */
    async oauthAuthorize(requestParameters: OauthAuthorizeRequest): Promise<OauthResponse> {
        if (requestParameters.clientIdentifier === null || requestParameters.clientIdentifier === undefined) {            
            throw new runtime.RequiredError('clientIdentifier','Required parameter requestParameters.clientIdentifier was null or undefined when calling oauthAuthorize.');
        }
        
        if (requestParameters.redirectUrl === null || requestParameters.redirectUrl === undefined) {            
            throw new runtime.RequiredError('redirectUrl','Required parameter requestParameters.redirectUrl was null or undefined when calling oauthAuthorize.');
        }
        
        if (requestParameters.responseType === null || requestParameters.responseType === undefined) {            
            throw new runtime.RequiredError('responseType','Required parameter requestParameters.responseType was null or undefined when calling oauthAuthorize.');
        }
        
        if (requestParameters.state === null || requestParameters.state === undefined) {            
            throw new runtime.RequiredError('state','Required parameter requestParameters.state was null or undefined when calling oauthAuthorize.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.clientIdentifier) {
            queryParameters['clientIdentifier'] = requestParameters.clientIdentifier;
        }

        
        if (requestParameters.redirectUrl) {
            queryParameters['redirectUrl'] = requestParameters.redirectUrl;
        }

        
        if (requestParameters.responseType) {
            queryParameters['responseType'] = requestParameters.responseType;
        }

        
        if (requestParameters.state) {
            queryParameters['state'] = requestParameters.state;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/authorize`,
            action: 'oauth:authorize',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Deauthorizes an oauth user
     */
    async oauthDeauthorize(requestParameters: OauthDeauthorizeRequest): Promise<void> {
        if (requestParameters.accessToken === null || requestParameters.accessToken === undefined) {            
            throw new runtime.RequiredError('accessToken','Required parameter requestParameters.accessToken was null or undefined when calling oauthDeauthorize.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.accessToken) {
            queryParameters['accessToken'] = requestParameters.accessToken;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/deauthorize`,
            action: 'oauth:deauthorize',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * Initiates OAuth access request and return parameters
     */
    async oauthInitiate(requestParameters: OauthInitiateRequest): Promise<RedirectResponse> {
        if (requestParameters.redirect === null || requestParameters.redirect === undefined) {            
            throw new runtime.RequiredError('redirect','Required parameter requestParameters.redirect was null or undefined when calling oauthInitiate.');
        }
        
        if (requestParameters.service === null || requestParameters.service === undefined) {            
            throw new runtime.RequiredError('service','Required parameter requestParameters.service was null or undefined when calling oauthInitiate.');
        }
        
        if (requestParameters.type === null || requestParameters.type === undefined) {            
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling oauthInitiate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.redirect) {
            queryParameters['redirect'] = requestParameters.redirect;
        }

        
        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.service !== undefined || requestParameters.service !== null) {
            pathParameters['service'] = requestParameters.service;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/initiate/{service}`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters.service))),
            action: 'oauth:initiate',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Delete a user\'s oauth service connection
     */
    async oauthServiceDelete(requestParameters: OauthServiceDeleteRequest): Promise<void> {
        if (requestParameters.id === null || requestParameters.id === undefined) {            
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling oauthServiceDelete.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.id !== undefined || requestParameters.id !== null) {
            pathParameters['id'] = requestParameters.id;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/service/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            action: 'oauthService:delete',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * List a user\'s oauth service connections
     */
    async oauthServiceList(requestParameters: OauthServiceListRequest): Promise<OAuthServiceListResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.ascending) {
            queryParameters['ascending'] = requestParameters.ascending;
        }

        
        if (requestParameters.limit) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.offset) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.service) {
            queryParameters['service'] = requestParameters.service;
        }

        
        if (requestParameters.sort) {
            queryParameters['sort'] = requestParameters.sort;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/service`,
            action: 'oauthService:list',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Show a user\'s oauth service connection
     */
    async oauthServiceShow(requestParameters: OauthServiceShowRequest): Promise<OAuthServiceResponse> {
        if (requestParameters.id === null || requestParameters.id === undefined) {            
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling oauthServiceShow.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.id !== undefined || requestParameters.id !== null) {
            pathParameters['id'] = requestParameters.id;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/service/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            action: 'oauthService:show',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Create a oauth service subscription
     */
    async oauthServiceSubscriptionCreate(requestParameters: OauthServiceSubscriptionCreateRequest): Promise<OauthServiceSubscriptionResponse> {
        if (requestParameters.model === null || requestParameters.model === undefined) {            
            throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling oauthServiceSubscriptionCreate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.creation) {
            queryParameters['creation'] = requestParameters.creation;
        }

        
        if (requestParameters.deletion) {
            queryParameters['deletion'] = requestParameters.deletion;
        }

        
        if (requestParameters.model) {
            queryParameters['model'] = requestParameters.model;
        }

        
        if (requestParameters.oauthServiceId) {
            queryParameters['oauthServiceId'] = requestParameters.oauthServiceId;
        }

        
        if (requestParameters.updates) {
            queryParameters['updates'] = requestParameters.updates;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/service/subscription`,
            action: 'oauthServiceSubscription:create',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Delete a oauth service subscription
     */
    async oauthServiceSubscriptionDelete(requestParameters: OauthServiceSubscriptionDeleteRequest): Promise<void> {
        if (requestParameters.id === null || requestParameters.id === undefined) {            
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling oauthServiceSubscriptionDelete.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.id !== undefined || requestParameters.id !== null) {
            pathParameters['id'] = requestParameters.id;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/service/subscription/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            action: 'oauthServiceSubscription:delete',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * List oauth service subscriptions
     */
    async oauthServiceSubscriptionList(requestParameters: OauthServiceSubscriptionListRequest): Promise<OauthServiceSubscriptionListResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.ascending) {
            queryParameters['ascending'] = requestParameters.ascending;
        }

        
        if (requestParameters.authorization) {
            queryParameters['authorization'] = requestParameters.authorization;
        }

        
        if (requestParameters.limit) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.model) {
            queryParameters['model'] = requestParameters.model;
        }

        
        if (requestParameters.offset) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.service) {
            queryParameters['service'] = requestParameters.service;
        }

        
        if (requestParameters.sort) {
            queryParameters['sort'] = requestParameters.sort;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/service/subscription`,
            action: 'oauthServiceSubscription:list',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Show an oauth service subscription
     */
    async oauthServiceSubscriptionShow(requestParameters: OauthServiceSubscriptionShowRequest): Promise<OauthServiceSubscriptionResponse> {
        if (requestParameters.id === null || requestParameters.id === undefined) {            
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling oauthServiceSubscriptionShow.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.id !== undefined || requestParameters.id !== null) {
            pathParameters['id'] = requestParameters.id;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/service/subscription/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            action: 'oauthServiceSubscription:show',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Returns tokens for third party oauth
     */
    async oauthToken(requestParameters: OauthTokenRequest): Promise<void> {
        if (requestParameters.clientIdentifier === null || requestParameters.clientIdentifier === undefined) {            
            throw new runtime.RequiredError('clientIdentifier','Required parameter requestParameters.clientIdentifier was null or undefined when calling oauthToken.');
        }
        
        if (requestParameters.clientSecret === null || requestParameters.clientSecret === undefined) {            
            throw new runtime.RequiredError('clientSecret','Required parameter requestParameters.clientSecret was null or undefined when calling oauthToken.');
        }
        
        if (requestParameters.grantType === null || requestParameters.grantType === undefined) {            
            throw new runtime.RequiredError('grantType','Required parameter requestParameters.grantType was null or undefined when calling oauthToken.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.authorizationCode) {
            queryParameters['authorizationCode'] = requestParameters.authorizationCode;
        }

        
        if (requestParameters.clientIdentifier) {
            queryParameters['clientIdentifier'] = requestParameters.clientIdentifier;
        }

        
        if (requestParameters.clientSecret) {
            queryParameters['clientSecret'] = requestParameters.clientSecret;
        }

        
        if (requestParameters.grantType) {
            queryParameters['grantType'] = requestParameters.grantType;
        }

        
        if (requestParameters.refreshToken) {
            queryParameters['refreshToken'] = requestParameters.refreshToken;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/oauth/token`,
            action: 'oauth:token',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

    }

    /**
     * 1
     * Update a user profile
     */
    async profileUpdate(requestParameters: ProfileUpdateRequest): Promise<ProfileResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.birthday) {
            queryParameters['birthday'] = (requestParameters.birthday as any).toISOString();
        }

        
        if (requestParameters.gender) {
            queryParameters['gender'] = requestParameters.gender;
        }

        
        if (requestParameters.language) {
            queryParameters['language'] = requestParameters.language;
        }

        
        if (requestParameters.name) {
            queryParameters['name'] = requestParameters.name;
        }

        
        if (requestParameters.units) {
            queryParameters['units'] = requestParameters.units;
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user/profile`,
            action: 'profile:update',
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Create a user weight measurement
     */
    async weightMeasurementCreate(requestParameters: WeightMeasurementCreateRequest): Promise<WeightMeasurementResponse> {
        if (requestParameters.metricWeight === null || requestParameters.metricWeight === undefined) {            
            throw new runtime.RequiredError('metricWeight','Required parameter requestParameters.metricWeight was null or undefined when calling weightMeasurementCreate.');
        }
        
        if (requestParameters.source === null || requestParameters.source === undefined) {            
            throw new runtime.RequiredError('source','Required parameter requestParameters.source was null or undefined when calling weightMeasurementCreate.');
        }
        
        if (requestParameters.takenAt === null || requestParameters.takenAt === undefined) {            
            throw new runtime.RequiredError('takenAt','Required parameter requestParameters.takenAt was null or undefined when calling weightMeasurementCreate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.bodyFatPercentage) {
            queryParameters['bodyFatPercentage'] = requestParameters.bodyFatPercentage;
        }

        
        if (requestParameters.metricWeight) {
            queryParameters['metricWeight'] = requestParameters.metricWeight;
        }

        
        if (requestParameters.source) {
            queryParameters['source'] = requestParameters.source;
        }

        
        if (requestParameters.takenAt) {
            queryParameters['takenAt'] = (requestParameters.takenAt as any).toISOString();
        }

        
        if (requestParameters.userId) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user/weight-measurement`,
            action: 'weightMeasurement:create',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

}
